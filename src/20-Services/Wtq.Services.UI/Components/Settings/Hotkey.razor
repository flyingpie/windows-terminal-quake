@using Wtq.Services.UI.Extensions

@inject IWtqBus Bus

@code {

	private bool _isSuper;

	[EditorRequired]
	[Parameter]
	public HotkeyOptions Options { get; set; } = new();

	[EditorRequired]
	[Parameter]
	public Action OnRemove { get; set; }

	private string Description
	{
		get
		{
			var s = Options.Sequence;
			return s.IsEmpty
				? "(press a shortcut here)"
				: s.ToString();

			// if (Options.Key != Keys.None || Options.Modifiers != KeyModifiers.None)
			// {
			// 	return Options.ToString();
			// }
			//
			// return "(press a shortcut here)";
		}
	}

	public string? RawEvent { get; set; }

	public string? RawSequence { get; set; }

	private void Clear()
	{
		Options.Modifiers = KeyModifiers.None;
		Options.Key = KeyCode.None;
		Options.KeyChar = null;
	}

	private void HandleFocusGained(FocusEventArgs e) => Bus.Publish<WtqSuspendHotkeysEvent>();

	private void HandleFocusLost(FocusEventArgs e) => Bus.Publish<WtqResumeHotkeysEvent>();

	private void HandleKeyDown(KeyboardEventArgs e)
	{
		RawEvent = Json.Serialize(e);

		// if (e.IsSuperKey())
		// {
		// 	_isSuper = true;
		// }

		e.ToModifiersAndKey(out var mod, out var keyChar, out var keyCode);

		// if (_isSuper)
		// {
		// 	mod |= KeyModifiers.Super;
		// }

		// For some reason, the KeyboardEventArgs.MetaKey bool isn't set to "TRUE" when the meta/super/windows key is pressed.
		// So we're keeping track of that ourselves.
		if (keyCode.IsSuper())
		{
			_isSuper = true;
		}

		if (_isSuper)
		{
			mod |= KeyModifiers.Super;
		}

		// If the pressed key is a modifier, omit it from the key code and key char.
		if (keyCode.IsModifier())
		{
			keyChar = null;
			keyCode = KeyCode.None;
		}

		// If a proper key char is available, omit the key code.
		if (!string.IsNullOrWhiteSpace(keyChar))
		{
			keyCode = KeyCode.None;
		}

		// If shift is pressed, and the character is "shifted", remove shift from the modifier set.
		// TODO: Explain why
		// TODO: Move to KWin-specific part.
		if (mod.HasFlag(KeyModifiers.Shift) && keyChar != null && keyChar.All(c => !char.IsUpper(c) && !char.IsLower(c)))
		{
			mod ^= KeyModifiers.Shift;
		}

		Options.Modifiers = mod;
		Options.Key = keyCode;
		Options.KeyChar = keyChar;

		Console.WriteLine(
			$"IS_SUPER:{_isSuper} " +
			$"ALT:{e.AltKey} " +
			$"CTRL:{e.CtrlKey} " +
			$"META:{e.MetaKey} " +
			$"SHIFT:{e.ShiftKey} " +
			$"KEY_CODE:{e.Code} " +
			$"KEY_CHAR:{e.Key} " +
			$"EV_TYPE:{e.Type} " +
			$"LOCATION:{e.Location} " +
			$"IsComposing:{e.IsComposing}");

		Console.WriteLine($"SEQ_SHORT:{Options.Sequence}");

		RawSequence = Json.Serialize(Options.Sequence);

		// _isSuper = false;
	}

	private void HandleKeyUp(KeyboardEventArgs e)
	{
		e.ToModifiersAndKey(out var mod, out var keyChar, out var keyCode);

		if (keyCode.IsSuper())
		{
			_isSuper = false;
		}
	}

	public char KeyChar => (Options?.KeyChar ?? " ")[0];

}

<RadzenStack Orientation="Orientation.Vertical">
	<RadzenStack Orientation="Orientation.Horizontal" AlignItems="AlignItems.Center" Gap="8">

		<!-- Shortcut capturing textbox -->
		<!-- We're preventing default actions so we can intercept more stuff that's already bound to something (like "F5" without refreshing the page). -->
		<input
			class="rz-textbox"
			Style="width: 100%;"
			@onkeydown="HandleKeyDown"
			@onkeydown:preventDefault="true"

			@onkeyup="HandleKeyUp"

			@onfocus="HandleFocusGained"
			@onblur="HandleFocusLost"

			Placeholder="Type here to set hotkey."
			Value="@Description"
		/>

		<!-- Clear button -->
		<RadzenButton
			Icon="backspace"
			Size="ButtonSize.Medium"
			Click="@(() => Clear())"
		/>

		<!-- Remove button -->
		<RadzenButton
			Icon="delete"
			Size="ButtonSize.Medium"
			Click="@(() => OnRemove())"
		/>

	</RadzenStack>

	<h4>EVENT</h4>
	<pre>@RawEvent</pre>

	<h4>SEQUENCE</h4>
	<pre>@RawSequence</pre>

	<pre>IS_UPPER:@(char.IsUpper((Options?.KeyChar ?? " ")[0]))</pre>
	<pre>IS_LOWER:@(char.IsLower((Options?.KeyChar ?? " ")[0]))</pre>
</RadzenStack>